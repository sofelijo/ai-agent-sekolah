<script>
document.addEventListener('DOMContentLoaded', () => {
    const form = document.getElementById('generateForm');
    const fieldsContainer = document.getElementById('generateFormFields');
    const tplLite = document.getElementById('tplGenerateLite');
    const tplPro = document.getElementById('tplGeneratePro');
    const generatorModeInput = document.getElementById('generateMode');
    const preview = document.getElementById('generatePreview');
    const promptTextArea = document.getElementById('generatedPromptText');
    const saveBtn = document.getElementById('saveGenerated');
    const statusBox = document.getElementById('tkaStatus');
    const triggerBtns = document.querySelectorAll('[data-generator-submit]');
    const copyPromptBtn = document.getElementById('copyPromptBtn');
    const importJsonBtn = document.getElementById('importJsonBtn');
    const importJsonInput = document.getElementById('importJsonInput');
    const importJsonModalEl = document.getElementById('importJsonModal');
    const importJsonTextarea = document.getElementById('importJsonTextarea');
    const importJsonFileInput = document.getElementById('importJsonFileInput');
    const confirmImportJsonBtn = document.getElementById('confirmImportJsonBtn');
    const importMapelSelect = document.getElementById('importMapelSelect');
    const importTopicSelect = document.getElementById('importTopicSelect');
    const importJsonModal = importJsonModalEl && window.bootstrap
        ? new bootstrap.Modal(importJsonModalEl)
        : null;
    let promptStale = true;
    const PROMPT_PREFIX = 'baut langsung bisa di klik tombol copy :\n';
    const baseGeneratorMode = (generatorModeInput ? generatorModeInput.value : 'lite').toLowerCase();
    const isLitePage = baseGeneratorMode === 'lite';
    let stimulusCache = [];
    let testCache = [];
    let testSubjectCache = {};
    let generatedBundle = null;
    let isGenerating = false;
    let isSavingQuestions = false;

    const selectors = {
        test: () => document.getElementById('generateTest'),
        subject: () => document.getElementById('generateSubject'),
        section: () => document.getElementById('generateSection'),
        grade: () => document.getElementById('generateGrade'),
        topic: () => document.getElementById('generateTopic'),
        difficulty: () => document.getElementById('generateDifficulty'),
        amount: () => document.getElementById('generateAmount'),
        bundle: () => document.getElementById('generateBundleSize'),
        questionType: () => document.getElementById('generateQuestionType'),
        answerMode: () => document.getElementById('generateAnswerMode'),
        formatType: () => document.getElementById('generateFormatType'),
        formatPg: () => document.getElementById('generateFormatPg'),
        formatTf: () => document.getElementById('generateFormatTf'),
        styleSimilarity: () => document.getElementById('generateStyleSimilarity'),
        example: () => document.getElementById('generateExample'),
        stimulusFormat: () => document.querySelector('input[name="stimulusFormat"]:checked'),
        storyParagraphs: () => document.getElementById('storyParagraphLength'),
        imageDescription: () => document.getElementById('generateImageDescription'),
        imageDescriptionGroup: () => document.getElementById('generateImageDescriptionGroup'),
        scope: () => document.querySelector('input[name="generatorScope"]:checked'),
        stimulusSection: () => document.getElementById('generatorStimulusSection'),
        stimulusSelect: () => document.getElementById('questionStimulusSelect'),
        stimulusSearch: () => document.getElementById('stimulusSearchInput'),
        clearStimulusSearch: () => document.getElementById('clearStimulusSearch'),
        refreshStimulus: () => document.getElementById('refreshStimulusBtn'),
        stimulusPreview: () => document.getElementById('selectedStimulusPreview'),
        amountGroup: () => document.getElementById('generateAmountGroup'),
        bundleLabel: () => document.getElementById('generateBundleLabel'),
        amountHint: () => document.getElementById('generateAmountHint'),
        amountLabel: () => document.getElementById('generateAmountLabel'),
        stimulusFormatGroup: () => document.getElementById('stimulusFormatGroup'),
    };
    const manualTestSelect = document.getElementById('manualTest');
    const manualSubjectSelect = document.getElementById('questionSubject');
    let manageTopicsUrl = '';
    let questionTypeWrapper = null;
    let currentSubjectSelection = { testId: null, subjectId: null, testSubjectId: null, mapelId: null };

    function encodePayload(data) {
        try {
            return btoa(encodeURIComponent(JSON.stringify(data)));
        } catch (error) {
            return '';
        }
    }

    function decodePayload(raw) {
        if (!raw) return null;
        try {
            return JSON.parse(decodeURIComponent(atob(raw)));
        } catch (error) {
            return null;
        }
    }

    function formatPromptForDisplay(rawPrompt) {
        const normalized = (rawPrompt || '').replace(PROMPT_PREFIX, '').replace(`${PROMPT_PREFIX.trimEnd()} `, '').trimStart();
        return `${PROMPT_PREFIX}${normalized}`;
    }

    function setPromptTextareaContent(rawPrompt) {
        if (!promptTextArea) return;
        promptTextArea.value = formatPromptForDisplay(rawPrompt);
        promptStale = false;
    }

    function markPromptStale() {
        promptStale = true;
        if (promptTextArea) {
            promptTextArea.value = '';
        }
    }

    function normalizeImportedQuestion(question) {
        if (!question || typeof question !== 'object') return null;
        const options = (() => {
            if (Array.isArray(question.options)) return question.options;
            if (Array.isArray(question.choices)) {
                return question.choices.map((text, idx) => ({
                    key: String.fromCharCode(65 + idx),
                    text,
                }));
            }
            if (question.option_map && typeof question.option_map === 'object') {
                return Object.entries(question.option_map).map(([key, text]) => ({ key, text }));
            }
            return [];
        })();
        return {
            prompt: question.prompt || question.question || '',
            topic: question.topic || '',
            difficulty: question.difficulty || 'easy',
            correct_key: question.correct_key || question.answer || (options[0]?.key || 'A'),
            explanation: question.explanation || question.explain || '',
            options,
            metadata: Object.assign({}, question.metadata || {}, {
                true_false_statements: Array.isArray(question.statements) ? question.statements : (question.metadata?.true_false_statements || []),
            }),
            stimulus: question.stimulus || null,
            generator_mode: question.generator_mode || question.mode || 'import_json',
            question_type: question.question_type || question.answer_format || 'multiple_choice',
        };
    }

    function getStimulusFormatChoice() {
        const radio = selectors.stimulusFormat();
        return radio ? radio.value : 'story';
    }

    function syncStoryParagraphVisibility() {
        const select = selectors.storyParagraphs();
        if (!select) return;
        const mode = resolveGeneratorMode();
        const format = getStimulusFormatChoice();
        const enable = mode !== 'pro' && format === 'story';
        select.disabled = !enable;
    }

    function resolveGeneratorMode() {
        if (baseGeneratorMode !== 'pro') return baseGeneratorMode;
        const scope = selectors.scope();
        if (scope && scope.value === 'questions_only') return 'pro';
        return 'bundle';
    }

    function showStatus(message, tone = 'info') {
        if (!statusBox) return;
        statusBox.className = `alert alert-${tone}`;
        statusBox.textContent = message;
        statusBox.classList.remove('d-none');
        setTimeout(() => statusBox.classList.add('d-none'), 3500);
    }

    async function copyTextToClipboard(text) {
        if (!text) return false;
        if (navigator.clipboard && navigator.clipboard.writeText) {
            try {
                await navigator.clipboard.writeText(text);
                return true;
            } catch (err) {
                // fallback below
            }
        }
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        let succeeded = false;
        try {
            succeeded = document.execCommand('copy');
        } catch (err) {
            succeeded = false;
        }
        document.body.removeChild(textarea);
        return succeeded;
    }

    function validateGeneratorPayload(payload) {
        if (!payload.topic) {
            return {
                ok: false,
                message: 'Pilih topik terlebih dahulu.',
                previewMessage: 'Pilih topik terlebih dahulu sebelum generate soal.',
            };
        }
        if (payload.generator_mode === 'pro' && !payload.stimulus_id) {
            return {
                ok: false,
                message: 'Pilih stimulus terlebih dahulu sebelum generate soal.',
                previewMessage: 'Pilih stimulus dulu sebelum generate soal.',
            };
        }
        return { ok: true };
    }

    function injectTemplate() {
        if (!fieldsContainer) return;
        const tpl = baseGeneratorMode === 'pro' ? tplPro : tplLite;
        if (tpl) {
            fieldsContainer.innerHTML = tpl.innerHTML;
            questionTypeWrapper = document.getElementById('questionTypeWrapper');
            const topicSelect = document.getElementById('generateTopic');
            if (topicSelect && topicSelect.dataset.manageUrl) {
                manageTopicsUrl = topicSelect.dataset.manageUrl;
            }
        }
    }

    function getStimulusSelection() {
        if (resolveGeneratorMode() !== 'pro') return null;
        const select = selectors.stimulusSelect();
        const value = select ? parseInt(select.value, 10) : NaN;
        return Number.isFinite(value) && value ? value : null;
    }

    function getSelectedMapelInfo() {
        const subjectSelect = selectors.subject();
        const opt = subjectSelect && subjectSelect.selectedOptions && subjectSelect.selectedOptions.length
            ? subjectSelect.selectedOptions[0]
            : null;
        const mapelId = opt ? parseInt(opt.dataset?.mapelId || opt.dataset?.mapel_id || opt.value, 10) : NaN;
        const testSubjectId = opt ? parseInt(opt.dataset?.testSubjectId || '', 10) : NaN;
        return {
            mapelId: Number.isFinite(mapelId) ? mapelId : null,
            testSubjectId: Number.isFinite(testSubjectId) ? testSubjectId : null,
        };
    }

    function getSectionMeta() {
        const sectionSelect = selectors.section();
        const fallback = { key: 'matematika', subject_area: 'matematika' };
        if (!sectionSelect) return fallback;
        const selectedOption = sectionSelect.options[sectionSelect.selectedIndex];
        const key = sectionSelect.value || fallback.key;
        const subjectArea = selectedOption?.dataset?.subjectArea;
        return {
            key: key || fallback.key,
            subject_area: subjectArea || (key.startsWith('bahasa') ? 'bahasa_indonesia' : fallback.subject_area),
        };
    }

    function syncFormatCountsFromInputs() {
        const formatSelect = selectors.formatType();
        const amountInput = selectors.amount();
        const pgInput = selectors.formatPg();
        const tfInput = selectors.formatTf();
        const answerSelect = selectors.answerMode();
        let selectedFormat = (formatSelect?.value === 'true_false') ? 'true_false'
            : (formatSelect?.value === 'mix') ? 'mix'
            : 'multiple_choice';
        let total = parseInt(amountInput?.value || '0', 10);
        if (!Number.isFinite(total) || total <= 0) {
            total = 3;
        }
        if (amountInput) {
            amountInput.value = String(total);
        }
        if (selectedFormat === 'true_false') {
            if (pgInput) pgInput.value = '0';
            if (tfInput) tfInput.value = String(total);
        } else if (selectedFormat === 'mix') {
            const half = Math.max(1, Math.floor(total / 2));
            if (pgInput) pgInput.value = String(total - half);
            if (tfInput) tfInput.value = String(half);
        } else {
            if (pgInput) pgInput.value = String(total);
            if (tfInput) tfInput.value = '0';
        }
        if (answerSelect) {
            answerSelect.value = selectedFormat;
        }
    }

    function applySubjectMetaFromOption(option) {
        const pgValue = option ? parseInt(option.dataset.pg || '0', 10) || 0 : 0;
        const tfValue = option ? parseInt(option.dataset.tf || '0', 10) || 0 : 0;
        const formatSelect = selectors.formatType();
        let selectedFormat = formatSelect ? formatSelect.value : 'multiple_choice';
        if (tfValue > 0 && pgValue === 0) {
            selectedFormat = 'true_false';
        } else if (pgValue > 0 && tfValue === 0) {
            selectedFormat = 'multiple_choice';
        } else if (pgValue > 0 || tfValue > 0) {
            selectedFormat = pgValue >= tfValue ? 'multiple_choice' : 'mix';
        }
        if (formatSelect) {
            formatSelect.value = selectedFormat;
        }
        syncFormatCountsFromInputs();
        const gradeSelect = selectors.grade();
        const gradeLevel = option ? (option.dataset.gradeLevel || option.dataset.grade || '') : '';
        if (gradeSelect && gradeLevel) {
            gradeSelect.value = gradeLevel;
        }
        const sectionSelect = selectors.section();
        const subjectArea = option ? (option.dataset.subjectArea || '').toLowerCase() : '';
        if (sectionSelect) {
            sectionSelect.value = subjectArea === 'bahasa_indonesia' ? 'bahasa_pg' : 'matematika';
        }
        updateQuestionTypeVisibility(subjectArea);
    }

    function bindFormatControls() {
        const formatSelect = selectors.formatType();
        const amountInput = selectors.amount();
        if (formatSelect) {
            formatSelect.addEventListener('change', () => syncFormatCountsFromInputs());
        }
        if (amountInput) {
            amountInput.addEventListener('input', () => syncFormatCountsFromInputs());
        }
        syncFormatCountsFromInputs();
    }

    function updateQuestionTypeVisibility(subjectArea) {
        const wrapper = questionTypeWrapper;
        const questionTypeSelect = selectors.questionType();
        if (!wrapper || !questionTypeSelect) return;
        const visible = subjectArea === 'matematika';
        wrapper.style.display = visible ? '' : 'none';
        if (!visible) {
            questionTypeSelect.value = 'story';
        }
    }

    function findSelectedSubjectEntry() {
        const testSelect = selectors.test();
        const subjectSelect = selectors.subject();
        if (!testSelect || !subjectSelect) return null;
        const testId = testSelect.value;
        const testSubjectId = subjectSelect.selectedOptions && subjectSelect.selectedOptions.length
            ? subjectSelect.selectedOptions[0].dataset.testSubjectId
            : null;
        if (!testId) return null;
        const list = testSubjectCache[testId] || testSubjectCache[String(testId)] || [];
        if (testSubjectId) {
            const direct = list.find(item => String(item.id) === String(testSubjectId));
            if (direct) return direct;
        }
        const subjectId = subjectSelect.value;
        if (!subjectId) return null;
        return list.find(item => String(item.subject_id || item.mapel_id) === String(subjectId)) || null;
    }

    function getCurrentTestSubjects() {
        const testSelect = selectors.test();
        if (!testSelect || !testSelect.value) return [];
        return testSubjectCache[testSelect.value] || testSubjectCache[String(testSelect.value)] || [];
    }

    function syncCurrentSubjectSelection(option) {
        if (!option) {
            currentSubjectSelection = { testId: null, subjectId: null, testSubjectId: null };
            return;
        }
        const parsedSubjectId = Number.parseInt(option.dataset?.mapelId || option.value, 10);
        const parsedTestSubjectId = Number.parseInt(option.dataset?.testSubjectId || '', 10);
        currentSubjectSelection = {
            testId: selectors.test() ? selectors.test().value : null,
            subjectId: Number.isFinite(parsedSubjectId) ? parsedSubjectId : null,
            testSubjectId: Number.isFinite(parsedTestSubjectId) ? parsedTestSubjectId : null,
            mapelId: Number.isFinite(parsedSubjectId) ? parsedSubjectId : null,
        };
    }

    function resolveSubjectSelection() {
        const subjectSelect = selectors.subject();
        const currentTestId = selectors.test() ? selectors.test().value : null;
        if (
            currentSubjectSelection.testId
            && currentSubjectSelection.testId === currentTestId
            && currentSubjectSelection.subjectId
            && currentSubjectSelection.testSubjectId
        ) {
            return { ...currentSubjectSelection };
        }
        if (!subjectSelect || !subjectSelect.options.length) {
            return { subjectId: null, testSubjectId: null };
        }
        let option = subjectSelect.selectedOptions && subjectSelect.selectedOptions.length
            ? subjectSelect.selectedOptions[0]
            : subjectSelect.options[subjectSelect.selectedIndex >= 0 ? subjectSelect.selectedIndex : 0];
        if (!option || !option.value) {
            option = subjectSelect.options[0];
        }
        syncCurrentSubjectSelection(option);
        return { ...currentSubjectSelection };
    }

    function populateTopicOptions(subjectEntry) {
        const topicSelect = selectors.topic();
        if (!topicSelect || topicSelect.tagName !== 'SELECT') return;
        const prevValue = topicSelect.dataset.lastValue || '';
        topicSelect.innerHTML = '';
        const manageOption = document.createElement('option');
        manageOption.value = '__manage__';
        manageOption.textContent = '+ Tambah topik di halaman Tes';
        topicSelect.appendChild(manageOption);
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.disabled = true;
        placeholder.textContent = (subjectEntry && Array.isArray(subjectEntry.topics) && subjectEntry.topics.length)
            ? 'Pilih topik'
            : 'Belum ada topik';
        placeholder.selected = true;
        topicSelect.appendChild(placeholder);
        if (!subjectEntry || !Array.isArray(subjectEntry.topics) || !subjectEntry.topics.length) {
            topicSelect.dataset.lastValue = '';
            return;
        }
        let matched = false;
        subjectEntry.topics.forEach(topic => {
            if (!topic || !topic.topic) return;
            const opt = document.createElement('option');
            opt.value = topic.topic;
            opt.textContent = topic.topic;
            if (topic.topic === prevValue) {
                opt.selected = true;
                matched = true;
            }
            topicSelect.appendChild(opt);
        });
        if (matched) {
            topicSelect.dataset.lastValue = prevValue;
            return;
        }
        topicSelect.selectedIndex = 1;
        topicSelect.dataset.lastValue = '';
    }

    function bindTopicSelect() {
        const topicSelect = selectors.topic();
        if (!topicSelect || topicSelect.tagName !== 'SELECT') return;
        topicSelect.addEventListener('change', () => {
            if (topicSelect.value === '__manage__') {
                const targetUrl = topicSelect.dataset.manageUrl || manageTopicsUrl || '/latihan-tka/tests';
                window.open(targetUrl, '_blank', 'noopener');
                const revertValue = topicSelect.dataset.lastValue || '';
                if (revertValue) {
                    topicSelect.value = revertValue;
                } else {
                    topicSelect.selectedIndex = 1;
                }
                return;
            }
            topicSelect.dataset.lastValue = topicSelect.value;
        });
        populateTopicOptions(null);
    }

    function buildPayload() {
        const testId = selectors.test() ? parseInt(selectors.test().value, 10) : NaN;
        const resolved = resolveSubjectSelection();
        const subjectId = resolved.subjectId;
        const testSubjectId = resolved.testSubjectId;
        const mapelId = resolved.mapelId;
        const subjectSelect = selectors.subject();
        const subjectLabel = subjectSelect && subjectSelect.selectedOptions && subjectSelect.selectedOptions.length
            ? (subjectSelect.selectedOptions[0].textContent || '').trim()
            : '';
        const rawTopic = selectors.topic() ? selectors.topic().value : '';
        const topicValue = rawTopic === '__manage__' ? '' : rawTopic;
        const selectedMode = resolveGeneratorMode();
        const stimulusFormat = getStimulusFormatChoice();
        const storyParagraphSelect = selectors.storyParagraphs();
        let storyParagraphs = storyParagraphSelect ? parseInt(storyParagraphSelect.value, 10) : NaN;
        if (!Number.isFinite(storyParagraphs) || storyParagraphs <= 0) {
            storyParagraphs = 2;
        }
        const amountValue = selectors.amount() ? parseInt(selectors.amount().value, 10) || 0 : 0;
        const bundleInput = selectors.bundle();
        const rawBundle = bundleInput ? parseInt(bundleInput.value, 10) : NaN;
        const bundleSize = rawBundle || 3;
        const resolvedAnswerMode = selectors.answerMode() ? selectors.answerMode().value : 'multiple_choice';
        return {
            test_id: Number.isFinite(testId) ? testId : null,
            test_subject_id: Number.isFinite(testSubjectId) ? testSubjectId : null,
            mapel_id: Number.isFinite(mapelId) ? mapelId : null,
            subject_hint: subjectLabel,
            topic: topicValue,
            difficulty: selectors.difficulty() ? selectors.difficulty().value : 'easy',
            amount: selectedMode === 'pro' ? 1 : amountValue,
            grade_level: selectors.grade() ? selectors.grade().value : '',
            question_type: selectors.questionType() ? selectors.questionType().value : 'direct',
            answer_mode: resolvedAnswerMode || 'multiple_choice',
            style_similarity: selectors.styleSimilarity() ? selectors.styleSimilarity().value : '50',
            example: selectors.example() ? selectors.example().value : '',
            generator_mode: selectedMode,
            section_key: selectors.section() ? selectors.section().value : 'matematika',
            bundle_size: bundleSize,
            image_description: selectors.imageDescription() ? selectors.imageDescription().value : '',
            stimulus_style: stimulusFormat || '',
            story_paragraphs: stimulusFormat === 'story' ? storyParagraphs : null,
            stimulus_id: getStimulusSelection(),
        };
    }

    const escapeHtml = (value = '') => String(value || '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');

    function importQuestionsFromJson(rawText) {
        if (!rawText) {
            showStatus('File JSON kosong.', 'warning');
            return;
        }
        const splitNarrativeAndTable = (stimulus, fallbackNarrative = '') => {
            const rawNarrative = (stimulus && typeof stimulus.narrative === 'string')
                ? stimulus.narrative
                : (typeof fallbackNarrative === 'string' ? fallbackNarrative : '');
            const lines = rawNarrative.split('\n');
            const tableStart = lines.findIndex(line => line.trim().startsWith('|'));
            const tableLines = tableStart !== -1 ? lines.slice(tableStart).join('\n').trim() : '';
            const narrativeLines = tableStart !== -1 ? lines.slice(0, tableStart).join('\n').trim() : rawNarrative.trim();
            const bestNarrative = narrativeLines
                || (typeof fallbackNarrative === 'string' ? fallbackNarrative.trim() : '')
                || stimulus?.description
                || stimulus?.context
                || rawNarrative;
            return {
                table: (stimulus && stimulus.table) ? stimulus.table : (tableLines || null),
                narrative: bestNarrative,
            };
        };
        const parseJsonInput = (input) => {
            const normalizeQuotes = (text) => text.replace(/[“”]/g, '"').replace(/[‘’]/g, "'");
            const stripTrailingCommas = (text) => text.replace(/,\s*([}\]])/g, '$1');
            let text = (input || '').trim().replace(/^\uFEFF/, '');
            try {
                return JSON.parse(text);
            } catch (err) {
                // coba perbaiki kutip miring atau koma gantung
            }
            text = stripTrailingCommas(normalizeQuotes(text));
            try {
                return JSON.parse(text);
            } catch (err) {
                return null;
            }
        };
        const narrativeCandidates = (() => {
            const matches = [];
            const regex = /"narrative"\s*:\s*"([\s\S]*?)"/g;
            let match;
            while ((match = regex.exec(rawText)) !== null) {
                const value = match[1] || '';
                matches.push(value.replace(/\\n/g, '\n').replace(/\\"/g, '"'));
            }
            return matches;
        })();
        let parsed;
        parsed = parseJsonInput(rawText);
        if (!parsed) {
            showStatus('Format JSON tidak valid.', 'danger');
            return;
        }
        const extractQuestions = (data) => {
            if (Array.isArray(data)) return data;
            if (Array.isArray(data?.questions)) return data.questions;
            if (Array.isArray(data?.data?.questions)) return data.data.questions;
            if (Array.isArray(data?.stimulus)) {
                const collected = [];
                data.stimulus.forEach((stim, idx) => {
                    const stimQuestions = Array.isArray(stim?.questions) ? stim.questions : [];
                    const bundleKey = stim.bundle_key || (stim.id ? `stim-${stim.id}` : `stim-${Math.random().toString(16).slice(2, 8)}`);
                    const fallbackNarrative = narrativeCandidates[idx] || '';
                    const { table: detectedTable, narrative: cleanedNarrative } = splitNarrativeAndTable(stim, fallbackNarrative);
                    const baseStim = Object.assign({}, stim, {
                        bundle_key: bundleKey,
                        narrative: cleanedNarrative ?? (stim.narrative || ''),
                    });
                    if (detectedTable) baseStim.table = detectedTable;
                    stimQuestions.forEach(q => {
                        collected.push(Object.assign({}, q, { stimulus: baseStim }));
                    });
                });
                if (collected.length) return collected;
            }
            return [];
        };
        const questions = extractQuestions(parsed);
        if (!questions.length) {
            showStatus('Tidak ada soal ditemukan di file JSON.', 'warning');
            return;
        }
        const normalized = questions.map(normalizeImportedQuestion).filter(item => item && item.prompt);
        if (!normalized.length) {
            showStatus('Tidak ada soal valid untuk ditampilkan.', 'warning');
            return;
        }
        const topicSelect = selectors.topic();
        const forcedTopic = topicSelect ? (topicSelect.value || '').trim() : '';
        if (forcedTopic) {
            normalized.forEach(item => {
                item.topic = forcedTopic;
                if (!item.metadata) item.metadata = {};
                item.metadata.topic = forcedTopic;
            });
        }
        normalized.forEach(item => {
            item.generator_mode = 'bundle';
            item.answer_format = item.question_type || item.answer_format || 'multiple_choice';
        });
        const tfCount = normalized.filter(q => (q.question_type === 'true_false')).length;
        const pgCount = normalized.length - tfCount;
        const answerModeSelect = selectors.answerMode();
        const formatSelect = selectors.formatType();
        if (answerModeSelect) {
            if (tfCount && !pgCount) {
                answerModeSelect.value = 'true_false';
            } else if (tfCount && pgCount) {
                answerModeSelect.value = 'mix';
            } else {
                answerModeSelect.value = 'multiple_choice';
            }
        }
        if (formatSelect) {
            if (tfCount && !pgCount) {
                formatSelect.value = 'true_false';
            } else if (tfCount && pgCount) {
                formatSelect.value = 'mix';
            } else {
                formatSelect.value = 'multiple_choice';
            }
            syncFormatCountsFromInputs();
        }
        const importedMeta = {
            prompt: parsed?.prompt || '',
            mode: parsed?.generator_mode || parsed?.mode || 'import_json',
            section_key: parsed?.section_key || parsed?.subject_area || '',
        };
        renderPreview(normalized, normalized.length);
        generatedBundle = {
            questions: normalized,
            prompt: importedMeta.prompt,
            mode: importedMeta.mode,
            requested: normalized.length,
            section_key: importedMeta.section_key,
        };
        setPromptTextareaContent(importedMeta.prompt || '');
        showStatus('Soal dari JSON berhasil dimuat untuk direview.', 'success');
        if (saveBtn) {
            saveBtn.disabled = false;
        }
        if (preview && typeof preview.scrollIntoView === 'function') {
            preview.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }

    function renderStimulusPreview(stimulus) {
        const previewBox = selectors.stimulusPreview();
        if (!previewBox) return;
        if (!stimulus) {
            previewBox.innerHTML = '<div class="alert alert-light border mb-0">Pilih stimulus untuk melihat detailnya.</div>';
            return;
        }
        const tableHtml = stimulus.table
            ? `<pre class="bg-light p-2 rounded border small mb-2">${escapeHtml(stimulus.table)}</pre>`
            : '';
        const imageHtml = stimulus.image_url
            ? `<img src="${escapeHtml(stimulus.image_url)}" alt="Gambar stimulus" class="img-fluid rounded mb-2">`
            : '';
        previewBox.innerHTML = `
            <div class="card border-0 shadow-sm">
                <div class="card-body p-3">
                    <div class="d-flex justify-content-between align-items-start mb-2">
                        <div>
                            <h6 class="mb-1">${escapeHtml(stimulus.title || 'Stimulus')}</h6>
                            <div class="text-muted small">ID: ${escapeHtml(stimulus.id || '-')}</div>
                        </div>
                        ${stimulus.type ? `<span class="badge text-bg-light text-uppercase">${escapeHtml(stimulus.type)}</span>` : ''}
                    </div>
                    ${imageHtml}
                    ${tableHtml}
                    <p class="small mb-1">${escapeHtml(stimulus.narrative || 'Narasi belum tersedia.')}</p>
                    ${stimulus.image_prompt ? `<div class="small text-muted">Deskripsi gambar: ${escapeHtml(stimulus.image_prompt)}</div>` : ''}
                </div>
            </div>
        `;
    }

    function renderStimulusOptions(selectedId = null) {
        const select = selectors.stimulusSelect();
        if (!select) return;
        let list = Array.isArray(stimulusCache) ? stimulusCache : [];
        const keyword = (selectors.stimulusSearch()?.value || '').trim().toLowerCase();
        if (keyword) {
            list = list.filter(item => (item.title || `stimulus-${item.id || ''}`).toLowerCase().includes(keyword));
        }
        select.innerHTML = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = list.length ? 'Pilih stimulus' : 'Belum ada stimulus';
        select.appendChild(placeholder);
        list.forEach(item => {
            const opt = document.createElement('option');
            opt.value = item.id;
            opt.textContent = item.title ? item.title : `Stimulus #${item.id || ''}`;
            select.appendChild(opt);
        });
        if (selectedId) {
            select.value = String(selectedId);
        }
        const current = list.find(item => Number(item.id) === Number(select.value)) || null;
        renderStimulusPreview(current);
    }

    async function loadStimulusList(selectedId = null) {
        const select = selectors.stimulusSelect();
        const subjectSelect = selectors.subject();
        const subjectId = subjectSelect ? parseInt(subjectSelect.value, 10) : NaN;
        const resolved = resolveSubjectSelection();
        const mapelId = resolved.mapelId;
        if (!select) return;
        if ((!Number.isFinite(subjectId) || !subjectId) && (!Number.isFinite(mapelId) || !mapelId)) {
            stimulusCache = [];
            renderStimulusOptions();
            return;
        }
        select.innerHTML = '<option value="">Memuat stimulus…</option>';
        try {
            const params = new URLSearchParams();
            if (Number.isFinite(subjectId) && subjectId) params.append('subject_id', subjectId);
            if (Number.isFinite(mapelId) && mapelId) params.append('mapel_id', mapelId);
            const response = await fetch(`/latihan-tka/stimulus?${params.toString()}`);
            const data = await response.json();
            if (response.ok && data.success !== false) {
                stimulusCache = Array.isArray(data.stimulus) ? data.stimulus : [];
                renderStimulusOptions(selectedId);
            } else {
                stimulusCache = [];
                renderStimulusOptions();
                showStatus((data && data.message) || 'Gagal memuat daftar stimulus.', 'danger');
            }
        } catch (error) {
            stimulusCache = [];
            renderStimulusOptions();
            showStatus('Gagal memuat daftar stimulus.', 'danger');
        }
    }

    function updateScopeUi() {
        const mode = resolveGeneratorMode();
        const stimSection = selectors.stimulusSection();
        if (stimSection) {
            stimSection.classList.toggle('d-none', mode !== 'pro');
        }
        const amountGroup = selectors.amountGroup();
        if (amountGroup) {
            amountGroup.classList.toggle('d-none', mode === 'pro');
        }
        const bundleLabel = selectors.bundleLabel();
        if (bundleLabel) {
            bundleLabel.textContent = mode === 'pro' ? 'Jumlah soal dari stimulus ini' : 'Soal per stimulus';
        }
        const amountHint = selectors.amountHint();
       
        const amountLabel = selectors.amountLabel();
        if (amountLabel) {
            amountLabel.textContent = mode === 'pro' ? 'Jumlah stimulus' : 'Jumlah stimulus';
        }
        const amt = selectors.amount();
        if (mode === 'pro' && amt) {
            amt.value = 1;
        }
        const imageGroup = selectors.imageDescriptionGroup();
        if (imageGroup) {
            imageGroup.classList.toggle('d-none', mode === 'pro');
        }
        const stimFormatGroup = selectors.stimulusFormatGroup();
        if (stimFormatGroup) {
            stimFormatGroup.classList.toggle('d-none', mode === 'pro');
        }
        syncStoryParagraphVisibility();
    }

    function buildStimulusBlock(stimulus) {
        const bundleKey = stimulus?.bundle_key || (stimulus?.id ? `stim-${stimulus.id}` : `stim-${Math.random().toString(16).slice(2, 8)}`);
        const payload = Object.assign({}, stimulus || {}, { bundle_key: bundleKey });
        const narrativeHasTable = (payload.narrative || '').split('\n').some(line => line.trim().startsWith('|'));
        const showTableBlock = payload.table && !narrativeHasTable;
        const stimCard = document.createElement('div');
        stimCard.className = 'stimulus-block mb-3';
        stimCard.dataset.bundleKey = bundleKey;
        stimCard.dataset.payload = encodePayload(payload);
        stimCard.innerHTML = `
            <div class="d-flex justify-content-between align-items-start mb-2">
                <div>
                    <div class="text-muted text-uppercase small">Stimulus</div>
                    <input type="text" class="form-control form-control-sm fw-semibold mb-1" data-stimulus-field="title" value="${escapeHtml(payload.title || 'Stimulus')}">
                    ${payload.id ? `<div class="small text-muted">ID: ${escapeHtml(payload.id)}</div>` : ''}
                </div>
                ${payload.type ? `<span class="badge text-bg-light">${escapeHtml(payload.type)}</span>` : ''}
            </div>
            <div class="mb-2">
                <label class="form-label small mb-1">Narasi</label>
                <textarea class="form-control form-control-sm" rows="3" data-stimulus-field="narrative">${escapeHtml(payload.narrative || '')}</textarea>
            </div>
            ${showTableBlock ? `
            <div class="mb-2">
                <label class="form-label small mb-1">Tabel</label>
                <textarea class="form-control form-control-sm font-monospace" rows="4" data-stimulus-field="table" readonly>${escapeHtml(payload.table)}</textarea>
            </div>
            ` : ''}
            <div class="mb-2">
                <label class="form-label small mb-1">Deskripsi gambar (opsional)</label>
                <textarea class="form-control form-control-sm" rows="2" data-stimulus-field="image_prompt">${escapeHtml(payload.image_prompt || '')}</textarea>
            </div>
            ${payload.image_url ? `<div class="small text-muted mb-1">Preview gambar: <a href="${escapeHtml(payload.image_url)}" target="_blank" rel="noopener">Buka</a></div>` : ''}
        `;
        return stimCard;
    }

    function persistQuestionPayload(card, question, sectionMeta, stimulus, questionType) {
        const stimMeta = stimulus ? Object.assign({}, stimulus, {
            bundle_key: stimulus.bundle_key || (stimulus.id ? `stim-${stimulus.id}` : 'no-stimulus'),
        }) : null;
        const payload = {
            generator_mode: question?.generator_mode || resolveGeneratorMode(),
            question_type: questionType || question?.question_type || 'multiple_choice',
            metadata: Object.assign({}, question?.metadata || {}),
            stimulus: stimMeta || question?.stimulus || null,
        };
        // Paksa subject_area mengikuti pilihan terkini supaya tidak ikut metadata lama/AI
        payload.metadata.section_key = sectionMeta.subject_area;
        payload.metadata.subject_area = sectionMeta.subject_area;
        if ((questionType || question?.question_type) === 'true_false') {
            const tfStatements = Array.isArray(question?.statements) ? question.statements : (payload.metadata.true_false_statements || []);
            payload.metadata.true_false_statements = tfStatements;
        }
        card.dataset.payload = encodePayload(payload);
    }

    function createQuestionCard(question, ordinal, sectionMeta, stimulus) {
        const rawTfStatements = Array.isArray(question?.statements) && question.statements.length
            ? question.statements
            : (Array.isArray(question?.metadata?.true_false_statements) ? question.metadata.true_false_statements : []);
        const tfStatements = [0, 1, 2].map(idx => rawTfStatements[idx] || { text: '', answer: 'benar' });
        const opts = Array.isArray(question?.options) && question.options.length ? question.options : [
            { key: 'A', text: '' },
            { key: 'B', text: '' },
            { key: 'C', text: '' },
            { key: 'D', text: '' },
        ];
        const rawType = question?.question_type
            || question?.metadata?.question_type
            || (question?.generator_mode === 'truefalse' ? 'true_false' : 'multiple_choice');
        const questionType = rawType === 'truefalse' ? 'true_false' : rawType;
        const card = document.createElement('div');
        card.className = 'question-card generated-question mb-3';
        card.dataset.index = String(ordinal - 1);
        card.innerHTML = `
            <div class="d-flex justify-content-between align-items-center mb-2">
                <div class="d-flex align-items-center gap-2">
                    <span class="fw-semibold">Soal ${ordinal}</span>
                    <span class="badge text-bg-light text-uppercase">${escapeHtml(question?.difficulty || 'easy')}</span>
                    ${questionType === 'true_false' ? '<span class="badge text-bg-info">Benar/Salah</span>' : ''}
                </div>
                <div class="btn-group btn-group-sm">
                    <button type="button" class="btn btn-outline-info" data-action="check-duplicate">Cek duplikat</button>
                    <button type="button" class="btn btn-outline-danger" data-action="remove">Hapus</button>
                </div>
            </div>
            <label class="form-label small mb-1">Teks Soal</label>
            <textarea class="form-control mb-2" data-field="prompt" rows="2">${question?.prompt || ''}</textarea>
            <div class="row g-2 mb-2">
                <div class="col-md-6">
                    <label class="form-label small">Topik</label>
                    <input type="text" class="form-control" data-field="topic" value="${question?.topic || ''}">
                </div>
                <div class="col-md-3">
                    <label class="form-label small">Kesulitan</label>
                    <select class="form-select" data-field="difficulty">
                        <option value="easy" ${question?.difficulty === 'easy' ? 'selected' : ''}>Mudah</option>
                        <option value="medium" ${question?.difficulty === 'medium' ? 'selected' : ''}>Sedang</option>
                        <option value="hard" ${question?.difficulty === 'hard' ? 'selected' : ''}>Susah</option>
                    </select>
                </div>
                <div class="col-md-3">
                    <label class="form-label small">Kunci</label>
                    <input type="text" class="form-control" data-field="correct" value="${question?.correct_key || 'A'}">
                </div>
            </div>
            ${questionType === 'true_false' ? `
                <div class="mb-2">
                    <label class="form-label small">Pernyataan Benar/Salah</label>
                    <div class="row g-2">
                        ${tfStatements.slice(0, 3).map((st, idx) => `
                            <div class="col-12">
                                <div class="row g-2 align-items-center">
                                    <div class="col-md-9">
                                        <textarea class="form-control form-control-sm" rows="2" data-tf-text="${idx}" placeholder="Pernyataan ${idx + 1}">${st.text || ''}</textarea>
                                    </div>
                                    <div class="col-md-3">
                                        <select class="form-select form-select-sm" data-tf-answer="${idx}">
                                            <option value="benar" ${st.answer === 'benar' ? 'selected' : ''}>Benar</option>
                                            <option value="salah" ${st.answer === 'salah' ? 'selected' : ''}>Salah</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                <div class="mb-2">
                    <label class="form-label small">Pembahasan</label>
                    <textarea class="form-control" data-field="explanation" rows="2">${question?.explanation || ''}</textarea>
                </div>
            ` : `
                <div class="option-grid option-grid-4 mb-2">
                    ${opts.map(opt => `
                        <input type="text" class="form-control" data-option="${opt.key || ''}" value="${opt.text || ''}" placeholder="Opsi ${opt.key || ''}">
                    `).join('')}
                </div>
                <label class="form-label small">Pembahasan</label>
                <textarea class="form-control" data-field="explanation" rows="2">${question?.explanation || ''}</textarea>
            `}
        `;
        persistQuestionPayload(card, question || {}, sectionMeta, stimulus, questionType);
        return card;
    }

    function collectStimulusEdits() {
        const blocks = Array.from(preview.querySelectorAll('.stimulus-block'));
        const map = {};
        blocks.forEach(block => {
            const base = decodePayload(block.dataset.payload || '') || {};
            const key = block.dataset.bundleKey || base.bundle_key || (base.id ? `stim-${base.id}` : 'no-stimulus');
            const titleInput = block.querySelector('[data-stimulus-field="title"]');
            const narrativeInput = block.querySelector('[data-stimulus-field="narrative"]');
            const tableInput = block.querySelector('[data-stimulus-field="table"]');
            const imagePromptInput = block.querySelector('[data-stimulus-field="image_prompt"]');
            const updated = Object.assign({}, base, {
                bundle_key: key,
                title: titleInput ? titleInput.value : base.title,
                narrative: narrativeInput ? narrativeInput.value : base.narrative,
                table: tableInput ? (tableInput.value || tableInput.textContent || base.table) : base.table,
                image_prompt: imagePromptInput ? imagePromptInput.value : base.image_prompt,
            });
            map[key] = updated;
        });
        return map;
    }

    function attachStimulusTableMetadata(stimulus) {
        if (!stimulus) return stimulus;
        const meta = stimulus.metadata && typeof stimulus.metadata === 'object'
            ? Object.assign({}, stimulus.metadata)
            : {};
        if (stimulus.table && !meta.table) {
            meta.table = stimulus.table;
        }
        stimulus.metadata = meta;
        return stimulus;
    }

    function normalizeStimulusForSave(stimulus) {
        if (!stimulus) return stimulus;
        const merged = attachStimulusTableMetadata(Object.assign({}, stimulus));
        if (merged.table) {
            const narrative = merged.narrative || '';
            const hasTableInline = narrative.split('\n').some(line => line.trim().startsWith('|'));
            if (!hasTableInline) {
                merged.narrative = narrative ? `${narrative}\n${merged.table}` : merged.table;
            }
        }
        return merged;
    }

    function renderPreview(questions, requested = 0) {
        if (!preview) return;
        if (!questions || !questions.length) {
            preview.innerHTML = '<div class="alert alert-warning">ASKA tidak mengembalikan soal apapun.</div>';
            return;
        }
        const sectionMeta = getSectionMeta();
        const groups = [];
        questions.forEach((q, idx) => {
            const stimulus = q && typeof q === 'object' ? q.stimulus : null;
            const key = stimulus?.bundle_key || (stimulus?.id ? `stim-${stimulus.id}` : 'no-stimulus');
            let group = groups.find(item => item.key === key);
            if (!group) {
                if (stimulus) {
                    stimulus.bundle_key = key;
                }
                group = { key, stimulus, items: [] };
                groups.push(group);
            }
            group.items.push({ question: q, index: idx });
        });
        const container = document.createElement('div');
        let counter = 1;
        groups.forEach(group => {
            if (group.stimulus) {
                container.appendChild(buildStimulusBlock(group.stimulus));
            }
            group.items.forEach(item => {
                const card = createQuestionCard(item.question, counter, sectionMeta, group.stimulus);
                container.appendChild(card);
                counter += 1;
            });
        });
        preview.innerHTML = '';
        if (requested && questions.length < requested) {
            const warn = document.createElement('div');
            warn.className = 'alert alert-warning';
            warn.textContent = `ASKA hanya menghasilkan ${questions.length} dari ${requested} soal yang diminta.`;
            preview.appendChild(warn);
        }
        preview.appendChild(container);
        if (saveBtn) {
            saveBtn.disabled = false;
        }
    }

    function bindScopeControls() {
        const scopeRadios = document.querySelectorAll('input[name="generatorScope"]');
        if (scopeRadios && scopeRadios.length) {
            scopeRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    updateScopeUi();
                    if (resolveGeneratorMode() === 'pro') {
                        loadStimulusList();
                    }
                });
            });
        }
        const subjectSelect = selectors.subject();
        if (subjectSelect) {
            subjectSelect.addEventListener('change', () => {
                if (resolveGeneratorMode() === 'pro') {
                    loadStimulusList();
                }
                const option = subjectSelect.selectedOptions && subjectSelect.selectedOptions.length
                    ? subjectSelect.selectedOptions[0]
                    : null;
                applySubjectMetaFromOption(option);
                syncCurrentSubjectSelection(option);
                const subjectEntry = findSelectedSubjectEntry();
                populateTopicOptions(subjectEntry);
                subjectSelect.dataset.lastValue = subjectSelect.value || '';
            });
        }
        const testSelect = selectors.test();
        if (testSelect) {
            testSelect.addEventListener('change', () => {
                populateTestSubjects(testSelect.value);
                const gradeSelect = selectors.grade();
                const found = testCache.find(t => String(t.id) === String(testSelect.value));
                if (gradeSelect && found && found.grade_level) {
                    gradeSelect.value = found.grade_level;
                }
            });
        }
    }

    function bindStimulusControls() {
        const stimSelect = selectors.stimulusSelect();
        const searchInput = selectors.stimulusSearch();
        const refreshBtn = selectors.refreshStimulus();
        const clearBtn = selectors.clearStimulusSearch();
        if (stimSelect) {
            stimSelect.addEventListener('change', () => {
                const selected = stimulusCache.find(item => Number(item.id) === Number(stimSelect.value)) || null;
                renderStimulusPreview(selected);
            });
        }
        if (searchInput) {
            searchInput.addEventListener('input', () => renderStimulusOptions(stimSelect ? stimSelect.value : null));
        }
        if (clearBtn && searchInput) {
            clearBtn.addEventListener('click', () => {
                searchInput.value = '';
                renderStimulusOptions(stimSelect ? stimSelect.value : null);
            });
        }
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => loadStimulusList(stimSelect ? stimSelect.value : null));
        }
        const formatRadios = document.querySelectorAll('input[name="stimulusFormat"]');
        if (formatRadios && formatRadios.length) {
            formatRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    syncStoryParagraphVisibility();
                });
            });
        }
    }

    function bindSubmitTriggers() {
        if (!form) return;
        triggerBtns.forEach(btn => {
            if (btn.dataset.bound) return;
            btn.dataset.bound = '1';
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                const submitEvent = new Event('submit', { bubbles: true, cancelable: true });
                form.dispatchEvent(submitEvent);
            });
        });
    }

    function attachFormHandler() {
        if (!form || !preview || !saveBtn) return;
        if (form.dataset.boundSubmit) return;
        form.dataset.boundSubmit = '1';
        form.addEventListener('submit', async (event) => {
            event.preventDefault();
            if (isGenerating) return;
            const payload = buildPayload();
            const validation = validateGeneratorPayload(payload);
            if (!validation.ok) {
                if (preview) {
                    const warnText = validation.previewMessage || validation.message;
                    preview.innerHTML = `<div class="alert alert-warning">${warnText}</div>`;
                }
                showStatus(validation.message, 'warning');
                if (saveBtn) saveBtn.disabled = false;
                return;
            }
            isGenerating = true;
            saveBtn.disabled = true;
            preview.innerHTML = '<div class="alert alert-info">ASKA sedang menyiapkan soal…</div>';
            let submitBtn = event.submitter || document.querySelector('[data-generator-submit]');
            const initialText = submitBtn ? submitBtn.innerHTML : '';
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Memproses…';
            }
            try {
                const response = await fetch('/latihan-tka/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const rawText = await response.text();
                let data = {};
                try {
                    data = rawText ? JSON.parse(rawText) : {};
                } catch (parseErr) {
                    console.error('Parse error generator:', parseErr, rawText);
                }
                if (response.ok && data.success) {
                    const questions = Array.isArray(data.questions) ? data.questions : [];
                    const expectedQuestions = payload.generator_mode === 'pro'
                        ? (payload.bundle_size || questions.length)
                        : (payload.amount || questions.length);
                    generatedBundle = {
                        questions,
                        test_subject_id: payload.test_subject_id,
                        mapel_id: payload.mapel_id,
                        section_key: payload.section_key,
                        prompt: data.prompt || payload.example || '',
                        mode: payload.generator_mode,
                        requested: expectedQuestions || questions.length,
                    };
                    renderPreview(questions, expectedQuestions);
                    saveBtn.disabled = false;
                    if (data.prompt) {
                        setPromptTextareaContent(data.prompt);
                    }
                    if (data.prompt) {
                        console.debug('[TKA][generate] prompt', data.prompt);
                        try {
                            const formattedPrompt = formatPromptForDisplay(data.prompt);
                            setPromptTextareaContent(data.prompt);
                            const copied = await copyTextToClipboard(formattedPrompt);
                            if (copied) {
                                showStatus('ASKA berhasil menyiapkan draft soal dan prompt disalin.', 'success');
                            } else {
                                showStatus('ASKA berhasil menyiapkan draft soal. Prompt tersedia untuk disalin.', 'success');
                            }
                        } catch (copyErr) {
                            console.error('[TKA][generate] gagal menyalin prompt', copyErr);
                            showStatus('ASKA berhasil menyiapkan draft soal. Prompt tersedia di kolom bawah.', 'info');
                        }
                    } else {
                        showStatus('ASKA berhasil menyiapkan draft soal.', 'success');
                    }
                } else {
                    const detail = data.message || rawText || 'Gagal generate soal.';
                    preview.innerHTML = `<div class="alert alert-danger">Generator gagal: ${escapeHtml(detail)}</div>`;
                    showStatus(`Gagal generate (${response.status || '0'}): ${detail}`, 'danger');
                    saveBtn.disabled = false;
                }
            } catch (error) {
                preview.innerHTML = `<div class="alert alert-danger">Terjadi kesalahan jaringan: ${escapeHtml(error?.message || error)}</div>`;
                showStatus('Terjadi kesalahan jaringan saat generate.', 'danger');
                saveBtn.disabled = false;
            } finally {
                isGenerating = false;
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = initialText;
                }
            }
        });
    }

    async function handleCopyPrompt() {
        if (!copyPromptBtn || copyPromptBtn.dataset.loading === '1') return;
        const existingPrompt = promptTextArea ? (promptTextArea.value || '').trim() : '';
        if (existingPrompt && !promptStale) {
            const copied = await copyTextToClipboard(existingPrompt);
            showStatus(copied ? 'Prompt disalin dari hasil terakhir.' : 'Prompt terbaru siap, tapi tidak bisa disalin otomatis.', copied ? 'success' : 'warning');
            return;
        }
        const payload = buildPayload();
        const validation = validateGeneratorPayload(payload);
        if (!validation.ok) {
            showStatus(validation.message, 'warning');
            return;
        }
        console.debug('[TKA][copy-prompt] payload', payload);
        payload.preview_only = true;
        const initialHtml = copyPromptBtn.innerHTML;
        copyPromptBtn.dataset.loading = '1';
        copyPromptBtn.disabled = true;
        copyPromptBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';
        try {
            const response = await fetch('/latihan-tka/generate_soal_new', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
            });
            let data = {};
            try {
                data = await response.json();
            } catch (parseErr) {
                data = {};
            }
            if (response.ok && data.success && data.prompt) {
                setPromptTextareaContent(data.prompt);
                const formatted = formatPromptForDisplay(data.prompt);
                const success = await copyTextToClipboard(formatted);
                if (success) {
                    showStatus('Prompt disalin ke clipboard.', 'success');
                } else {
                    showStatus('Prompt siap, tapi browser menolak akses clipboard.', 'warning');
                }
            } else {
                showStatus((data && data.message) || 'Gagal mengambil prompt.', 'danger');
            }
        } catch (error) {
            console.error('[TKA][copy-prompt] error', error);
            showStatus('Terjadi kesalahan saat mengambil prompt.', 'danger');
        } finally {
            copyPromptBtn.disabled = false;
            copyPromptBtn.dataset.loading = '0';
            copyPromptBtn.innerHTML = initialHtml;
        }
    }

    function readQuestionsFromPreview() {
        const sectionMeta = getSectionMeta();
        const stimulusMap = collectStimulusEdits();
        if (!preview) return [];
        const cards = Array.from(preview.querySelectorAll('.question-card'));
        const testId = selectors.test() ? parseInt(selectors.test().value || '', 10) : null;
        const selection = getSelectedMapelInfo();
        const testSubjectId = selection.testSubjectId;
        const mapelId = selection.mapelId;
            const resolveStimulus = (stimulus) => {
                if (!stimulus) return null;
                const key = stimulus.bundle_key
                    || (stimulus.id ? `stim-${stimulus.id}` : null)
                    || 'no-stimulus';
                const edited = stimulusMap[key];
                const merged = Object.assign({}, edited || stimulus);
                merged.bundle_key = key;
                return normalizeStimulusForSave(merged);
            };
        const formatSelect = selectors.formatType();
        const globalFormatValue = formatSelect ? formatSelect.value : '';
        const answerModeValue = selectors.answerMode() ? selectors.answerMode().value : '';
        const forcedFormat = (() => {
            if (answerModeValue && answerModeValue !== 'mix') return answerModeValue;
            if (globalFormatValue && globalFormatValue !== 'mix') return globalFormatValue;
            return '';
        })();
        return cards.map(card => {
            const basePayload = decodePayload(card?.dataset?.payload || '') || {};
            const metadata = Object.assign({}, basePayload.metadata || {});
            const rawType = basePayload.question_type || (metadata.true_false_statements ? 'true_false' : 'multiple_choice');
            let questionType = rawType === 'truefalse' ? 'true_false' : rawType;
            if (forcedFormat) {
                questionType = forcedFormat === 'truefalse' ? 'true_false' : forcedFormat;
            }
            // Selalu sinkronkan kategori mapel dengan pilihan user saat ini
            metadata.section_key = sectionMeta.subject_area;
            metadata.subject_area = sectionMeta.subject_area;
            metadata.question_format = questionType;
            if (questionType === 'true_false' && !metadata.true_false_statements && basePayload.metadata?.true_false_statements) {
                metadata.true_false_statements = basePayload.metadata.true_false_statements;
            }
            const options = Array.from(card.querySelectorAll('[data-option]'))
                .filter(input => input.value.trim())
                .map(input => ({ key: input.dataset.option, text: input.value.trim() }));
            const tfStatements = [];
            if (questionType === 'true_false') {
                for (let i = 0; i < 3; i += 1) {
                    const textEl = card.querySelector(`[data-tf-text="${i}"]`);
                    const ansEl = card.querySelector(`[data-tf-answer="${i}"]`);
                    const text = textEl ? textEl.value.trim() : '';
                    const answer = ansEl ? ansEl.value : '';
                    if (text) {
                        tfStatements.push({ text, answer: answer === 'salah' ? 'salah' : 'benar' });
                    }
                }
                if (tfStatements.length === 0 && Array.isArray(basePayload.metadata?.true_false_statements)) {
                    tfStatements.push(...basePayload.metadata.true_false_statements);
                }
            }
            const result = {
                prompt: card.querySelector('[data-field="prompt"]')?.value?.trim() || '',
                topic: card.querySelector('[data-field="topic"]')?.value?.trim() || '',
                difficulty: card.querySelector('[data-field="difficulty"]')?.value || 'easy',
                correct_key: card.querySelector('[data-field="correct"]')?.value?.trim() || 'A',
                explanation: card.querySelector('[data-field="explanation"]')?.value?.trim() || '',
                options: questionType === 'true_false' ? [
                    { key: 'A', text: 'Benar' },
                    { key: 'B', text: 'Salah' },
                ] : options,
                statements: tfStatements.length ? tfStatements : (metadata.true_false_statements || basePayload.statements || []),
                metadata,
                stimulus: resolveStimulus(basePayload.stimulus),
                generator_mode: basePayload.generator_mode || resolveGeneratorMode(),
                question_type: questionType,
                answer_format: questionType,
                test_id: Number.isFinite(testId) ? testId : null,
                test_subject_id: Number.isFinite(testSubjectId) ? testSubjectId : null,
                mapel_id: Number.isFinite(mapelId) ? mapelId : null,
            };
            if (questionType === 'true_false') {
                result.correct_key = '';
            }
            return result;
        }).filter(item => item.prompt && (item.question_type === 'true_false' || item.options.length >= 2));
    }

    function attachPreviewActions() {
        if (!preview) return;
        preview.addEventListener('click', async (event) => {
            const removeBtn = event.target.closest('[data-action="remove"]');
            if (removeBtn) {
                const card = removeBtn.closest('.question-card');
                if (card) card.remove();
                if (!preview.querySelector('.question-card')) {
                    preview.innerHTML = '<div class="alert alert-warning">Semua soal dihapus. Generate ulang untuk mendapatkan soal.</div>';
                    saveBtn.disabled = true;
                }
                return;
            }
            const dupBtn = event.target.closest('[data-action="check-duplicate"]');
            if (dupBtn) {
                const card = dupBtn.closest('.question-card');
                const promptValue = card?.querySelector('[data-field="prompt"]')?.value?.trim() || '';
                const resolved = resolveSubjectSelection();
                const mapelId = resolved.mapelId;
                const testSubjectId = resolved.testSubjectId;
                if (!promptValue) {
                    showStatus('Isi teks soal sebelum cek duplikat.', 'warning');
                    return;
                }
                if (!testSubjectId && !mapelId) {
                    showStatus('Pilih mapel pada tes sebelum cek duplikat.', 'warning');
                    return;
                }
                dupBtn.disabled = true;
                dupBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';
                try {
                    const response = await fetch('/latihan-tka/questions/check-duplicate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            prompt: promptValue,
                            mapel_id: Number.isFinite(mapelId) ? mapelId : null,
                            test_subject_id: Number.isFinite(testSubjectId) ? testSubjectId : null,
                        })
                    });
                    const data = await response.json();
                    if (response.ok && data.success) {
                        card.classList.toggle('duplicate-found', data.exists);
                        card.classList.toggle('duplicate-clear', !data.exists);
                        showStatus(data.exists ? 'Soal sudah ada di bank soal.' : 'Tidak ditemukan duplikat.', data.exists ? 'danger' : 'success');
                    } else {
                        showStatus(data.message || 'Gagal mengecek duplikat.', 'danger');
                    }
                } catch (error) {
                    showStatus('Terjadi kesalahan saat cek duplikat.', 'danger');
                } finally {
                    dupBtn.disabled = false;
                    dupBtn.innerHTML = 'Cek duplikat';
                }
            }
        });
    }

    function attachSaveHandler() {
        if (!saveBtn || !preview) return;
        if (saveBtn.dataset.boundSave) return;
        saveBtn.dataset.boundSave = '1';
        saveBtn.addEventListener('click', async () => {
            if (isSavingQuestions) return;
            const testSelect = selectors.test();
            const testId = testSelect ? parseInt(testSelect.value, 10) : null;
            const selection = getSelectedMapelInfo();
            const mapelSelect = selectors.subject();
            const rawMapelId = mapelSelect ? parseInt(mapelSelect.value, 10) : NaN;
            const testSubjectId = selection.testSubjectId;
            const mapelId = Number.isFinite(rawMapelId) ? rawMapelId : selection.mapelId;
            if (!testSubjectId && !mapelId) {
                showStatus('Pilih mapel pada tes terlebih dahulu.', 'warning');
                return;
            }
            const questions = readQuestionsFromPreview();
            if (!questions.length) {
                showStatus('Tidak ada soal untuk disimpan.', 'warning');
                return;
            }
            const promptPayload = generatedBundle?.prompt || '';
            const sourceLabel = generatedBundle?.mode === 'pro'
                ? 'ai_pro'
                : (generatedBundle?.mode === 'import_json' ? 'import_json' : 'ai_lite');
            questions.forEach(item => {
                item.ai_prompt = promptPayload;
                item.source = sourceLabel;
                if (!item.test_id) item.test_id = Number.isFinite(testId) ? testId : null;
                if (!item.test_subject_id) item.test_subject_id = testSubjectId;
            });
            console.debug('[TKA][save] payload preview', {
                testId,
                mapelId,
                testSubjectId,
                count: questions.length,
                sample: questions[0],
            });
            saveBtn.disabled = true;
            saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Menyimpan…';
            isSavingQuestions = true;
            try {
                const response = await fetch('/latihan-tka/questions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        test_id: testId,
                        test_subject_id: testSubjectId,
                        mapel_id: mapelId,
                        questions,
                    }),
                });
                const data = await response.json();
                if (response.ok && data.success) {
                    showStatus(`${data.inserted || questions.length} soal tersimpan.`, 'success');
                    preview.innerHTML = '<div class="alert alert-success">Soal berhasil disimpan.</div>';
                    generatedBundle = null;
                } else {
                    showStatus(data.message || 'Gagal menyimpan soal.', 'danger');
                }
            } catch (error) {
                showStatus('Terjadi kesalahan saat menyimpan soal.', 'danger');
            } finally {
                saveBtn.disabled = false;
                saveBtn.innerHTML = '<i class="bi bi-save me-1"></i>Simpan ke Bank Soal';
                isSavingQuestions = false;
            }
        });
    }

    async function loadTests() {
        try {
            const res = await fetch('/latihan-tka/tests');
            const data = await res.json();
            if (res.ok && Array.isArray(data.tests)) {
                testCache = data.tests;
                await populateTests();
            }
        } catch (err) {
            // ignore silent fail
        }
    }

    async function populateTests() {
        const select = selectors.test();
        if (!select) return;
        select.innerHTML = '<option value="">Pilih tes</option>';
        testCache.forEach(test => {
            const opt = document.createElement('option');
            opt.value = test.id;
            opt.textContent = `${test.name} (${test.duration_minutes || 0}m)`;
            select.appendChild(opt);
        });
        if (manualTestSelect) {
            manualTestSelect.innerHTML = '<option value="">Pilih tes</option>';
            testCache.forEach(test => {
                const opt = document.createElement('option');
                opt.value = test.id;
                opt.textContent = `${test.name} (${test.duration_minutes || 0}m)`;
                manualTestSelect.appendChild(opt);
            });
        }
        if (testCache.length) {
            select.value = testCache[0].id;
            await populateTestSubjects(select.value);
            const gradeSelect = selectors.grade();
            if (gradeSelect && testCache[0].grade_level) {
                gradeSelect.value = testCache[0].grade_level;
            }
            if (manualTestSelect) {
                manualTestSelect.value = testCache[0].id;
                await populateManualSubjects(testCache[0].id);
            }
        }
    }

    async function populateTestSubjects(testId) {
        const subjectSelect = selectors.subject();
        if (!subjectSelect) return;
        if (!testId) {
            subjectSelect.innerHTML = '<option value="">Pilih jenis latihan</option>';
            populateTopicOptions(null);
            return;
        }
        if (!testSubjectCache[testId]) {
            try {
                const res = await fetch(`/latihan-tka/tests/${testId}/subjects`);
                const data = await res.json();
                if (res.ok && Array.isArray(data.subjects)) {
                    testSubjectCache[testId] = data.subjects;
                } else {
                    testSubjectCache[testId] = [];
                }
            } catch (err) {
                testSubjectCache[testId] = [];
            }
        }
        const list = testSubjectCache[testId] || [];
        subjectSelect.innerHTML = '';
        if (!list.length) {
            subjectSelect.innerHTML = '<option value="">Belum ada mapel</option>';
            populateTopicOptions(null);
            return;
        }
        const lastValue = subjectSelect.dataset.lastValue || subjectSelect.value || '';
        list.forEach(item => {
            const mapelId = item.mapel_id || item.subject_id;
            const opt = document.createElement('option');
            opt.value = mapelId || '';
            opt.dataset.mapelId = mapelId || '';
            opt.dataset.testSubjectId = item.id;
            opt.textContent = item.subject_name || `Mapel ${item.subject_id}`;
            opt.dataset.pg = (item.formats || []).find(f => f.question_type === 'multiple_choice')?.question_count_target || 0;
            opt.dataset.tf = (item.formats || []).find(f => f.question_type === 'true_false')?.question_count_target || 0;
            const gradeLevel = (item.grade_level || item.mapel_grade_level || '').toString().toLowerCase();
            if (gradeLevel) {
                opt.dataset.gradeLevel = gradeLevel;
            }
            let subjectArea = (item.subject_area || '').toString().toLowerCase();
            if (!subjectArea) {
                const normalizedName = (item.subject_name || '').toString().toLowerCase();
                subjectArea = normalizedName.includes('bahasa') ? 'bahasa_indonesia' : 'matematika';
            }
            opt.dataset.subjectArea = subjectArea || 'matematika';
            subjectSelect.appendChild(opt);
        });
        if (lastValue) {
            subjectSelect.value = lastValue;
        }
        if (!subjectSelect.value && list.length) {
            subjectSelect.value = list[0].mapel_id || list[0].subject_id;
        }
        const activeOption = subjectSelect.selectedOptions && subjectSelect.selectedOptions.length
            ? subjectSelect.selectedOptions[0]
            : subjectSelect.options && subjectSelect.options.length
                ? subjectSelect.options[subjectSelect.selectedIndex >= 0 ? subjectSelect.selectedIndex : 0]
                : null;
        syncCurrentSubjectSelection(activeOption);
        subjectSelect.dispatchEvent(new Event('change'));
    }

    async function populateManualSubjects(testId) {
        if (!manualSubjectSelect) return;
        if (!testId) {
            manualSubjectSelect.innerHTML = '<option value="">Pilih mapel</option>';
            return;
        }
        if (!testSubjectCache[testId]) {
            try {
                const res = await fetch(`/latihan-tka/tests/${testId}/subjects`);
                const data = await res.json();
                if (res.ok && Array.isArray(data.subjects)) {
                    testSubjectCache[testId] = data.subjects;
                } else {
                    testSubjectCache[testId] = [];
                }
            } catch (err) {
                testSubjectCache[testId] = [];
            }
        }
        const list = testSubjectCache[testId] || [];
        manualSubjectSelect.innerHTML = '';
        if (!list.length) {
            manualSubjectSelect.innerHTML = '<option value="">Belum ada mapel</option>';
            return;
        }
        const lastManualValue = manualSubjectSelect.dataset.lastValue || manualSubjectSelect.value || '';
        list.forEach(item => {
            const mapelId = item.mapel_id || item.subject_id;
            const opt = document.createElement('option');
            opt.value = mapelId || '';
            opt.dataset.mapelId = mapelId || '';
            opt.dataset.testSubjectId = item.id;
            opt.textContent = item.subject_name || `Mapel ${item.subject_id}`;
            opt.dataset.pg = (item.formats || []).find(f => f.question_type === 'multiple_choice')?.question_count_target || 0;
            opt.dataset.tf = (item.formats || []).find(f => f.question_type === 'true_false')?.question_count_target || 0;
            const gradeLevel = (item.grade_level || item.mapel_grade_level || '').toString().toLowerCase();
            if (gradeLevel) {
                opt.dataset.gradeLevel = gradeLevel;
            }
            let subjectArea = (item.subject_area || '').toString().toLowerCase();
            if (!subjectArea) {
                const normalizedName = (item.subject_name || '').toString().toLowerCase();
                subjectArea = normalizedName.includes('bahasa') ? 'bahasa_indonesia' : 'matematika';
            }
            opt.dataset.subjectArea = subjectArea || 'matematika';
            manualSubjectSelect.appendChild(opt);
        });
        if (lastManualValue) {
            manualSubjectSelect.value = lastManualValue;
        }
        if (!manualSubjectSelect.value && list.length) {
            manualSubjectSelect.value = list[0].mapel_id || list[0].subject_id;
        }
        manualSubjectSelect.dispatchEvent(new Event('change'));
    }

    injectTemplate();
    updateScopeUi();
    bindSubmitTriggers();
    bindScopeControls();
    bindFormatControls();
    updateQuestionTypeVisibility('');
    if (form) {
        ['input', 'change'].forEach(evt => {
            form.addEventListener(evt, () => markPromptStale(), { passive: true });
        });
    }
    if (importJsonBtn && importJsonModal) {
        importJsonBtn.addEventListener('click', (event) => {
            event.preventDefault();
            if (importJsonTextarea) {
                importJsonTextarea.value = '';
            }
            if (importJsonFileInput) {
                importJsonFileInput.value = '';
            }
            if (importMapelSelect && selectors.subject()) {
                importMapelSelect.innerHTML = selectors.subject().innerHTML;
                importMapelSelect.value = selectors.subject().value || '';
            }
            if (importTopicSelect && selectors.topic()) {
                importTopicSelect.innerHTML = selectors.topic().innerHTML;
                importTopicSelect.value = selectors.topic().value || '';
            }
            importJsonModal.show();
        });
    }
    if (confirmImportJsonBtn) {
        confirmImportJsonBtn.addEventListener('click', async () => {
            const pasted = importJsonTextarea ? importJsonTextarea.value.trim() : '';
            if (importMapelSelect && selectors.subject() && importMapelSelect.value !== selectors.subject().value) {
                selectors.subject().value = importMapelSelect.value;
                selectors.subject().dispatchEvent(new Event('change'));
            }
            if (importTopicSelect && selectors.topic()) {
                selectors.topic().value = importTopicSelect.value || selectors.topic().value;
            }
            if (pasted) {
                importQuestionsFromJson(pasted);
                importJsonModal?.hide();
                return;
            }
            const file = importJsonFileInput && importJsonFileInput.files ? importJsonFileInput.files[0] : null;
            if (!file) {
                showStatus('Pilih file JSON atau tempel konten terlebih dahulu.', 'warning');
                return;
            }
            try {
                const content = await file.text();
                importQuestionsFromJson(content);
                importJsonModal?.hide();
            } catch (err) {
                showStatus('Gagal membaca file JSON.', 'danger');
            }
        });
    }
    if (copyPromptBtn) {
        copyPromptBtn.addEventListener('click', (event) => {
            event.preventDefault();
            handleCopyPrompt();
        });
    }
    bindTopicSelect();
    bindStimulusControls();
    attachFormHandler();
    attachPreviewActions();
    attachSaveHandler();
    if (manualTestSelect) {
        manualTestSelect.addEventListener('change', () => {
            populateManualSubjects(manualTestSelect.value);
        });
    }
    if (manualSubjectSelect) {
        manualSubjectSelect.addEventListener('change', () => {
            const opt = manualSubjectSelect.selectedOptions[0];
            if (!opt) return;
            const pg = parseInt(opt.dataset.pg || '0', 10);
            const tf = parseInt(opt.dataset.tf || '0', 10);
            const categorySelect = document.getElementById('questionCategory');
            if (categorySelect) {
                categorySelect.value = (opt.textContent || '').toLowerCase().includes('bahasa') ? 'bahasa_indonesia' : 'matematika';
            }
            // optional: set mode defaults based on formats
            if (pg === 0 && tf > 0) {
                const tfMode = document.querySelector('input[name=\"questionMode\"][value=\"truefalse\"]');
                if (tfMode) tfMode.checked = true;
                updateManualModeSections('truefalse');
            }
        });
    }
    loadTests();
});
</script>
